(require lispy.macros *)

(from time [time])

;;; integer functions
(def gcd [x y]
  (= [x y] [(min x y) (max x y)])
  (while (> x 0)
    (= [x y] [(% y x) x]))
  (return y))

(def lcm [x y]
  (return (* x (// y (gcd x y)))))

;;; rational numbers functions
(def frac-reduce [x]
  (= [xn xd] x)
  (= [xn xd] (ife (< xd 0) [(- xn) (- xd)] [xn xd]))
  (= div (gcd (abs xn) xd))
  (return [(// xn div) (// xd div)]))

(def frac-add [x y]
  (= [xn xd] x)
  (= [yn yd] y)
  (= denom (lcm xd yd))
  (= numer (+ (* xn (// denom xd))
              (* yn (// denom yd))))
  (return (frac-reduce [numer denom])))

(def frac-mul [x y]
  (= [xn xd] x)
  (= [yn yd] y)
  (= denom (* xd yd))
  (= numer (* xn yn))
  (return (frac-reduce [numer denom])))

(def frac-neg [x]
  (= [xn xd] x)
  (return [(- xn) xd]))

(def reciprocal [x]
  (= [xn xd] x)
  (return [xd xn]))

(def digit-sum [x]
  (= rst 0)
  (while x
    (+= rst (% x 10))
    (//= x 10))
  (return rst))

(def solution [:n 33]
  (= seq [2])
  (= rst [1 1])
  (for i (range 1 (+ n 1))
    (seq.append 1)
    (seq.append (* 2 i))
    (seq.append 1))
  (seq.pop)
  (while seq
    (= rst (frac-add [(seq.pop) 1] (reciprocal rst))))
  (return (digit-sum (sub rst 0))))

(def main []
  (= start (time))
  (print (solution))
  (print "elapsed:" (- (time) start)))

(main)
