(require lispy.macros *)

(def lst-to-num [lst]
  (= ret 0)
  (for d lst
    (*= ret 10)
    (+= ret d))
  (return ret))

(def num-to-set [n]
  (= ret (set))
  (while n
    (ret.add (% n 10))
    (//= n 10))
  (return ret))

(defmacro with-permutations [perm candidates lengths *body]
  (return `(do
     (= __candidates ~candidates)
     (= __lengths (set ~lengths))
     (= __max-depth (max ~lengths))
     (= __terminate [])
     (= ~perm [])
     (def __recur [__l __d]
       (if (not __terminate)
           (do
             (if (in __l __lengths)
                 (do ~@body))
             (if __d
                 (for __c (list __candidates)
                   (.append ~perm __c)
                   (.remove __candidates __c)
                   (__recur (+ __l 1) (- __d 1))
                   (.add __candidates __c)
                   (.pop ~perm))))))
     (__recur 0 __max-depth))))

(def factors-found? [p candidates]
  ;; assume multiplicand < multiplier, length of multiplicand lies in [1 2]
  (= ret False)
  (with-permutations perm candidates [1 2]
    (= m (lst-to-num perm))
    (if (and (== (% p m) 0) (== candidates (num-to-set (// p m))))
        (do (nonlocal ret)
            (= ret True)
            (__terminate.append True))))
  (return ret))

(def sol []
  (= candidates (set (range 1 10)))
  ;; since (* 99 99) < 11111, (* 111 111), (* 11 111), (1 1111) > 9 product should be length of 4
  (= ret (set))
  (with-permutations perm candidates [4]
    (= p (lst-to-num perm))
    (if (factors-found? p candidates)
        (ret.add p)))
  (return (sum ret)))

(print (sol))
