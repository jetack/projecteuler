(require lispy.macros *)

(from time [time])
(from collections [defaultdict])

(def num-to-patterns [n]
  (= rst [])
  (= ns (str n))
  (def recur [s c rst :depth 0]
    (if (== depth (len s))
        (return rst))
    (if (== (sub s depth) c)
        (do (= new [])
            (for pattern rst
              (new.append (+ (sub pattern [: None depth])
                             "*"
                             (sub pattern [: (+ depth 1) None]))))
            (+= rst new)))
    (return (recur s c rst (+ depth 1))))
  (for c "0123456789"
    (+= rst (sub (recur ns c [ns]) [: 1 None])))
  (return rst))

(def get-next-p [primes]
  (= n (+ (sub primes -1) 2))
  (while True
    (for p primes
      (cond (> (* p p) n) (return n)
            (== 0 (% n p)) (break)))
    (+= n 2)))

(def solution [:n 8]
  (= pattern-mem (defaultdict list))
  (= primes [2 3 5])
  (= (sub pattern-mem "*") [2 3 5])
  (while True
    (= p (get-next-p primes))
    (primes.append p)
    (for pattern (num-to-patterns p)
      (= mem-lst (sub pattern-mem pattern))
      (.append mem-lst p)
      (if (== n (len mem-lst))
          (return mem-lst)))))

(def main []
  (= start (time))
  (print (solution))
  (print "elapsed:" (- (time) start)))

(main)
